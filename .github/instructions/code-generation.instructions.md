---
applyTo: "**/*.cs"
---

Code generation rules (for automated tools and contributors)

Purpose
- These rules guide automated code generation and human contributions that add new C# code to the repository. Keep rules focused on producing readable, documented, and testable code that fits the existing project structure.

Documentation
- Every newly generated public type or public member must include XML documentation (`/// <summary>...</summary>`) describing intent, important behavior, and any non-obvious side effects.
- Keep documentation concise and focused on the "why" and "what" (not line-by-line implementation details). Add usage examples in remarks when helpful.
- Internal types should have comments when their behavior is not obvious or when they encode important business rules.

Testability
- Generated code must be testable. Prefer small, single-responsibility methods and avoid large monolithic functions that are hard to test.
- Add unit tests for all new behavior. Place tests in the matching test project and follow the test project layout rules (one folder per production class, one file per method behavior).
- If logic needs integration or database-backed tests, separate them as integration tests and use Testcontainers where appropriate.

Abstractions and interfaces
- Do not create abstractions or interfaces without a clear reason. Avoid adding an interface solely to mock in tests — prefer testing concrete behavior via seams (e.g., factory or small wrapper) unless multiple implementations, plugin points, or external replaceability are required.
- If you introduce an abstraction, include an explanation in the commit/PR describing:
  - the problem being solved,
  - why a concrete implementation would be insufficient,
  - the expected lifecycle of the abstraction (temporary vs stable), and
  - any alternatives considered.
- Prefer `internal` types and sealed classes for implementations that are not intended to be extended.

Design and style
- Follow existing repository conventions for naming, folder layout, and project choices. Prefer small, focused classes that implement a single responsibility.
- Keep public surface area minimal. Favor well-named methods over many tiny layers.
- Use dependency injection for replaceable services, but only when the service is cross-cutting or will be provided by the host (CLI, web host, background service).

Placement and project selection
- Put generated code in the most appropriate existing project (Core, Data, Providers, CLI) based on responsibility. Do not create new top-level projects without justification.
- Update project files (`.csproj`) only if additional NuGet packages are required; prefer adding packages to the smallest-scope project that needs them.

Generated code markers
- For code generated by automated tools, include a short header comment indicating the file was generated and a brief note about regeneration (tool name or script). This helps reviewers and tooling to treat the file appropriately.

PR and review guidance
- When submitting generated code, include a short summary of what was generated, why it was needed, and the tests added to cover it.
- If abstractions were added, include the required justification (see Abstractions and interfaces).
- Ensure CI builds and tests pass before requesting review.

Security and secrets
- Never generate code that embeds secrets, credentials, or environment-specific values. Use configuration and secret stores instead.

Keep these rules concise and follow them when adding or generating C# code in the repository. If uncertain about a design choice, prefer asking for a short design review before generating large amounts of code.
